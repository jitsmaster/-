/**
 * There is a foreign language which uses the latin alphabet, but the order among letters is not "a", "b", "c" ... "z" as in English.
 *
 * You receive a list of non-empty strings words from the dictionary, where the words are sorted lexicographically based on the rules of this new language.
 *
 * Derive the order of letters in this language. If the order is invalid, return an empty string. If there are multiple valid order of letters, return any of them.
 *
 * A string a is lexicographically smaller than a string b if either of the following is true:
 *
 * The first letter where they differ is smaller in a than in b.
 * There is no index i such that a[i] != b[i] and a.length < b.length.
 * Example 1:
 *
 * Input: ["z","o"]
 *
 * Output: "zo"
 * Explanation:
 * From "z" and "o", we know 'z' < 'o', so return "zo".
 *
 * Example 2:
 *
 * Input: ["hrn","hrf","er","enn","rfnn"]
 *
 * Output: "hernf"
 * Explanation:
 *
 * from "hrn" and "hrf", we know 'n' < 'f'
 * from "hrf" and "er", we know 'h' < 'e'
 * from "er" and "enn", we know get 'r' < 'n'
 * from "enn" and "rfnn" we know 'e'<'r'
 * so one possibile solution is "hernf"
 * Constraints:
 *
 * The input words will contain characters only from lowercase 'a' to 'z'.
 * 1 <= words.length <= 100
 * 1 <= words[i].length <= 100
 */
function alienDictionary(words: string[]): string {
	//we can use topological sort to solve this problem
	//we can build a graph based on the order of characters
	//then we can do a topological sort to get the order of characters
	//if there is a cycle in the graph, then the order is invalid
	//we can use a hashmap to store the order of characters
	//then we can use a set to store the characters that have been visited
	//we can use a set to store the characters that are in the graph

	//Complexity Analysis:
	//Time: O(n), where n is the total number of characters in the dictionary, since we need to go through all the characters to build the graph
	//Space: O(n), where n is the total number of characters in the dictionary, since we need to store the graph, visited set, and result set

	//first build the graph, which is in the format of adjacency list
	const graph = new Map<string, Set<string>>();

	//add the characters to the graph
	//what we do is pair 2 words in the dictionary use them to get a character order
	//each 2 words we can only get 1 character order
	for (let i = 0; i < words.length - 1; i++) {
		const word1 = words[i];
		const word2 = words[i + 1];

		//edge case, if the word1 is longer than word2, then the order is invalid
		//can word 2 is the prefix of wor1, this is invalid
		if (word1.length > word2.length && word1.startsWith(word2)) {
			return "";
		}

		//find the first different character
		let j = 0;
		while (j < Math.min(word1.length, word2.length)) {
			const [char1, char2] = [word1[j], word2[j]];
			if (char1 !== char2) {
				if (!graph.has(char1)) {
					graph.set(char1, new Set());
				}

				graph.get(char1)!.add(char2);
				break;
			}
			j++;
		}
	}

	//now we have the graph, we can do a topological sort
	//which can be done with both dfs and bfs
	//dfs is easier to implement, so we will use it
	const visited = new Map<string, "" | "visiting" | "visited">();

	const result = new Array<string>();

	//this is called post order DFS: visit the children first, then visit the node
	//the result will be the reverse of the topological order
	function podfs(node: string): "valid" | "invalid" {

		if (visited.get(node) === "visiting") {
			return "invalid"; //cycle detected. it's being visited again in the same recursion stack
		}

		if (visited.get(node) === "visited") {
			return "valid"; //already visited, no need to visit again, breaking out of cycle
		}

		visited.set(node, "visiting");

		if (graph.has(node)) {
			for (const child of graph.get(node)!) {
				if (podfs(child) === "invalid") {
					return "invalid";
				}
			}
		}

		visited.set(node, "visited");
		result.push(node);

		return "valid";
	}

	//start the dfs from each node
	//only way to do topo sort
	//since we have visited set to track the visited nodes
	//we will not repeat
	for (const node of graph.keys()) {
		if (!visited.has(node) //very important, doesn't start from a visited node, or we will definitely get a false cycle
			&& podfs(node) === "invalid") {
			return "";
		}
	}

	//reverse the result to get the correct order, since it was generated by post order DFS
	result.reverse();
	return result.join("");
}
